


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Game</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">it.polimi.ingsw.controller</a>
</div>

<h1>Coverage Summary for Class: Game (it.polimi.ingsw.controller)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Game</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/560)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Game$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/561)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package it.polimi.ingsw.controller;
&nbsp;
&nbsp;
&nbsp;import it.polimi.ingsw.model.*;
&nbsp;import it.polimi.ingsw.view.IP;
&nbsp;import it.polimi.ingsw.view.Player;
&nbsp;import it.polimi.ingsw.view.PlayerI;
&nbsp;import it.polimi.ingsw.view.PlayerSend;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.net.InetAddress;
&nbsp;import java.net.ServerSocket;
&nbsp;import java.net.Socket;
&nbsp;import java.net.SocketException;
&nbsp;import java.rmi.RemoteException;
&nbsp;import java.rmi.registry.LocateRegistry;
&nbsp;import java.rmi.server.UnicastRemoteObject;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Random;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;
&nbsp;/**
&nbsp; * class which represent the instance of the current game
&nbsp; * @author Ettori Faccincani
&nbsp; * in theory it is mutable, but it is only instanced one time, at the start of the server
&nbsp; */
&nbsp;public class Game extends UnicastRemoteObject implements Serializable, GameI {
&nbsp;    /** variable that represent the standard timer of the app for advancing the state of the game */
&nbsp;    public static final double waitTimer = 2.5;
&nbsp;    /** variable that represent the fast timer of the app for small waiting task */
&nbsp;    public static final double fastTimer = 1;
&nbsp;    /** variable that represent the timer for the new turn (changing) interaction */
&nbsp;    public static final double passTimer = 1;
&nbsp;    /** variable that represent the standard timer of the app for showing events */
&nbsp;    public static final double showTimer = 2.5;
&nbsp;    /** variable that represent if we want to run or debug our application */
<b class="nc">&nbsp;    public static boolean showErrors = false;</b>
&nbsp;    private final int targetPlayers;
&nbsp;    private int numPlayers;
<b class="nc">&nbsp;    private int activePlayer = 0;</b>
<b class="nc">&nbsp;    private ArrayList&lt;PlayerSend&gt; players = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    private ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    private final transient ArrayList&lt;Socket&gt; playersSocket = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    private final transient ArrayList&lt;ObjectOutputStream&gt; outStreams = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    private final transient ArrayList&lt;ObjectInputStream&gt; inStreams = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    private final ArrayList&lt;CommonObjective&gt; bucketOfCO = Initializer.setBucketOfCO();</b>
<b class="nc">&nbsp;    private final ArrayList&lt;PrivateObjective&gt; bucketOfPO = Initializer.setBucketOfPO();</b>
<b class="nc">&nbsp;    private boolean endGameSituation = false;</b>
<b class="nc">&nbsp;    private boolean timeExp = true;</b>
<b class="nc">&nbsp;    private transient ArrayList&lt;Thread&gt; chatThreads = new ArrayList&lt;&gt;();</b>
&nbsp;    private transient ServerSocket serverSocket;
<b class="nc">&nbsp;    private transient boolean closed = false;</b>
<b class="nc">&nbsp;    private final transient HashMap&lt;String, PlayerI&gt; rmiClients = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;    private transient Game gameTemp = null;</b>
<b class="nc">&nbsp;    private final transient ArrayList&lt;String&gt; disconnectedPlayers = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;    private boolean advance = false; //true iif the server has to force a new turn after resilience activation</b>
<b class="nc">&nbsp;    private final transient Object disconnectionLock = new Object();</b>
<b class="nc">&nbsp;    private transient String playerNoChat = &quot;&quot;;</b>
&nbsp;    /**
&nbsp;     * normal constructor for this type of object, this class is also the main process on the server
&nbsp;     * @param maxP the number of players for this game, chosen before by the user
&nbsp;     * @param old contains yes/no, used to determine if the player wants to load and older game
&nbsp;     */
&nbsp;    public Game(int maxP, String old) throws RemoteException {
<b class="nc">&nbsp;        super();</b>
<b class="nc">&nbsp;        System.setProperty(&quot;java.rmi.server.hostname&quot;, IP.activeIP);</b>
&nbsp;        try {
<b class="nc">&nbsp;            LocateRegistry.createRegistry(Initializer.PORT_RMI).rebind(&quot;Server&quot;, this); // host the server on the network</b>
<b class="nc">&nbsp;        }catch (Exception e){</b>
<b class="nc">&nbsp;            System.out.println(&quot;\nPort 5555 is already used\n&quot;);</b>
<b class="nc">&nbsp;            System.exit(0);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        targetPlayers = maxP;</b>
<b class="nc">&nbsp;        if(old.equals(&quot;yes&quot;)){</b>
<b class="nc">&nbsp;            if(FILEHelper.havaCachedServer()) {// check if there&#39;s a server in the cache, if so, use it</b>
<b class="nc">&nbsp;                gameTemp = FILEHelper.loadServer();</b>
<b class="nc">&nbsp;                FILEHelper.writeFail();</b>
<b class="nc">&nbsp;                if(gameTemp.numPlayers != maxP) {</b>
<b class="nc">&nbsp;                    System.out.println(&quot;\nThe old game is not compatible, starting a new game...&quot;);</b>
<b class="nc">&nbsp;                    gameTemp = null;</b>
&nbsp;                }
&nbsp;                else {
<b class="nc">&nbsp;                    System.out.println(&quot;\nLoading the old game...&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            else {
<b class="nc">&nbsp;                System.out.println(&quot;\nThere is no game to load, starting a new game...&quot;);</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        FILEHelper.writeFail();</b>
<b class="nc">&nbsp;        shuffleObjBucket();</b>
<b class="nc">&nbsp;        numPlayers = 0;</b>
<b class="nc">&nbsp;        new Thread(() -&gt; { // start a timer that wait for clients connections</b>
<b class="nc">&nbsp;            double minutes = 2.5;</b>
<b class="nc">&nbsp;            Game.waitForSeconds(60 * minutes);</b>
<b class="nc">&nbsp;            if(!timeExp)</b>
&nbsp;                return;
<b class="nc">&nbsp;            System.out.println(&quot;\nTime limit exceeded, not enough players connected\n&quot;);</b>
<b class="nc">&nbsp;            System.exit(0);</b>
<b class="nc">&nbsp;        }).start();</b>
&nbsp;
<b class="nc">&nbsp;        try{serverSocket = new ServerSocket(Initializer.PORT, 10, InetAddress.getByName(IP.activeIP));}</b>
<b class="nc">&nbsp;        catch(Exception e){connectionLost(e);}</b>
<b class="nc">&nbsp;        System.out.println(&quot;\nServer listening... (@exit for closing the server)\n&quot;);</b>
&nbsp;
<b class="nc">&nbsp;        new Thread(() -&gt;{</b>
<b class="nc">&nbsp;            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</b>
&nbsp;            String s;
&nbsp;            while(true){
&nbsp;                try {
<b class="nc">&nbsp;                    s = br.readLine();</b>
<b class="nc">&nbsp;                } catch (IOException e) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if(!s.equals(&quot;@exit&quot;))</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                System.out.println(&quot;\nServer exiting...\n&quot;);</b>
<b class="nc">&nbsp;                Game.waitForSeconds(Game.fastTimer);</b>
<b class="nc">&nbsp;                System.exit(0);</b>
&nbsp;            }
<b class="nc">&nbsp;        }).start();</b>
&nbsp;
<b class="nc">&nbsp;        listenForPlayersConnections();</b>
&nbsp;
<b class="nc">&nbsp;        if(gameTemp != null){</b>
<b class="nc">&nbsp;            if(gameTemp.names.containsAll(names)) {</b>
<b class="nc">&nbsp;                initializeOldClients();</b>
<b class="nc">&nbsp;                if(gameTemp.endGameSituation){</b>
&nbsp;                    boolean temp; //variable used to check if the rmi is ready
<b class="nc">&nbsp;                    for(int i = 0; i &lt; numPlayers; i++) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            temp = (boolean)inStreams.get(i).readObject();</b>
<b class="nc">&nbsp;                        } catch (IOException | ClassNotFoundException e) {</b>
<b class="nc">&nbsp;                            connectionLost(e);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Game.waitForSeconds(Game.waitTimer);</b>
<b class="nc">&nbsp;                    sendFinalScoresToAll();</b>
&nbsp;                }
&nbsp;            }
&nbsp;            else{
<b class="nc">&nbsp;                System.out.println(&quot;\nThe names of the clients do not match the old ones, starting a new game...&quot;);</b>
<b class="nc">&nbsp;                initializeAllClients();</b>
&nbsp;            }
<b class="nc">&nbsp;            gameTemp = null;</b>
&nbsp;        }
&nbsp;        else
<b class="nc">&nbsp;            initializeAllClients();</b>
&nbsp;
<b class="nc">&nbsp;        new Thread(() -&gt;{</b>
&nbsp;            while (true){
<b class="nc">&nbsp;                Game.waitForSeconds(Game.waitTimer);</b>
<b class="nc">&nbsp;                if(getActivePlayersNumber() != 0)</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                System.out.println(&quot;\nThe server il closing because there are no connected players\n&quot;);</b>
<b class="nc">&nbsp;                System.exit(0);</b>
&nbsp;            }
<b class="nc">&nbsp;        }).start();</b>
&nbsp;
&nbsp;        boolean temp; //variable used to check if the rmi is ready
<b class="nc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                temp = (boolean)inStreams.get(i).readObject();</b>
<b class="nc">&nbsp;            } catch (IOException | ClassNotFoundException e) {</b>
<b class="nc">&nbsp;                connectionLost(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){</b>
<b class="nc">&nbsp;            if(rmiClients.containsKey(names.get(i)))</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            try {
<b class="nc">&nbsp;                playersSocket.get(i).setSoTimeout(Player.pingTimeout);</b>
<b class="nc">&nbsp;            } catch (SocketException e) {</b>
<b class="nc">&nbsp;                connectionLost(e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        new Thread(this::pingRMI).start();</b>
<b class="nc">&nbsp;        new Thread(this::listenForReconnection).start();</b>
<b class="nc">&nbsp;        if(!rmiClients.containsKey(names.get(0)))</b>
<b class="nc">&nbsp;            new Thread(this::waitMoveFromClient).start();</b>
&nbsp;        else
<b class="nc">&nbsp;            startChatServerThread();</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * method that get an old client status by his name
&nbsp;     * @param n the name of the old client
&nbsp;     * @param playerList the list of all the old clients
&nbsp;     * @author Ettori
&nbsp;     * @return the client that was playing previously and needs to be alive again
&nbsp;     */
&nbsp;    private Player getClientByName(String n, ArrayList&lt;PlayerSend&gt; playerList){
<b class="nc">&nbsp;        for(int i = 0; i &lt; playerList.size(); i++){</b>
<b class="nc">&nbsp;            if(playerList.get(i).name.equals(n)) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    return new Player(playerList.get(i));</b>
<b class="nc">&nbsp;                } catch (RemoteException e) {</b>
<b class="nc">&nbsp;                    connectionLost(e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        System.out.println(&quot;\nAncient client not found...&quot;);</b>
<b class="nc">&nbsp;        System.exit(0);</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * get the only player connected to the game currently
&nbsp;     * @return the index of the only player left active
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private int getLastPlayer(){
<b class="nc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){</b>
<b class="nc">&nbsp;            if(!disconnectedPlayers.contains(names.get(i)))</b>
<b class="nc">&nbsp;                return i;</b>
&nbsp;        }
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * helper method for initializing the old clients that were playing in the previous game
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private void initializeOldClients(){
<b class="nc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){</b>
&nbsp;            try {
<b class="nc">&nbsp;                gameTemp.players.get(i).activeName = gameTemp.names.get(0);</b>
<b class="nc">&nbsp;                outStreams.get(i).writeObject(new Player(getClientByName(names.get(i), gameTemp.players)));</b>
<b class="nc">&nbsp;                players.add(new PlayerSend(getClientByName(names.get(i), gameTemp.players)));</b>
<b class="nc">&nbsp;            }catch (Exception e){connectionLost(e);}</b>
&nbsp;        }
<b class="nc">&nbsp;        int temp = names.indexOf(gameTemp.names.get(0));</b>
<b class="nc">&nbsp;        String n = names.get(0);</b>
<b class="nc">&nbsp;        names.set(0, names.get(temp));</b>
<b class="nc">&nbsp;        names.set(temp, n);</b>
&nbsp;
<b class="nc">&nbsp;        ObjectOutputStream outTemp = outStreams.get(0);</b>
<b class="nc">&nbsp;        outStreams.set(0, outStreams.get(temp));</b>
<b class="nc">&nbsp;        outStreams.set(temp, outTemp);</b>
&nbsp;
<b class="nc">&nbsp;        ObjectInputStream inTemp = inStreams.get(0);</b>
<b class="nc">&nbsp;        inStreams.set(0, inStreams.get(temp));</b>
<b class="nc">&nbsp;        inStreams.set(temp, inTemp);</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * helper method for initializing all the clients (players) with the same board state
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private void initializeAllClients(){
<b class="nc">&nbsp;        randomizeChairman();</b>
<b class="nc">&nbsp;        Player p = null;</b>
<b class="nc">&nbsp;        for(int i = 0; i &lt; names.size(); i++){</b>
&nbsp;            try {
<b class="nc">&nbsp;                p = new Player();</b>
<b class="nc">&nbsp;            } catch (RemoteException e) {</b>
<b class="nc">&nbsp;                connectionLost(e);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            for(int j = 0; j &lt; numPlayers; j++){</b>
<b class="nc">&nbsp;                if(i == j)</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                try {
<b class="nc">&nbsp;                    p.pointsMap.put(names.get(j), 0);</b>
<b class="nc">&nbsp;                }catch (Exception e){</b>
<b class="nc">&nbsp;                    System.out.println(&quot;\nServer unable to start...\n&quot;);</b>
<b class="nc">&nbsp;                    System.exit(0);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;            p.setName(names.get(i));</b>
<b class="nc">&nbsp;            p.setIsChairMan(i == 0);</b>
<b class="nc">&nbsp;            p.board = new Board(numPlayers, bucketOfCO.get(0), bucketOfCO.get(1));</b>
<b class="nc">&nbsp;            p.board.name = names.get(i);</b>
<b class="nc">&nbsp;            if(i == 0)</b>
<b class="nc">&nbsp;                p.board.initBoard(numPlayers);</b>
&nbsp;            else
<b class="nc">&nbsp;                p.board = new Board(getChairman().board);</b>
<b class="nc">&nbsp;            p.library = new Library(names.get(i));</b>
<b class="nc">&nbsp;            p.setPrivateObjective(getPrivateObjective());</b>
<b class="nc">&nbsp;            p.pointsUntilNow = 0;</b>
<b class="nc">&nbsp;            p.activeName = getChairmanName();</b>
<b class="nc">&nbsp;            p.chairmanName = getChairmanName();</b>
&nbsp;            try {
<b class="nc">&nbsp;                for (int j = 0; j &lt; numPlayers; j++) {</b>
<b class="nc">&nbsp;                    if (!names.get(j).equals(names.get(i)))</b>
<b class="nc">&nbsp;                        p.librariesOfOtherPlayers.add(new Library(names.get(j)));</b>
&nbsp;                }
<b class="nc">&nbsp;            }catch (Exception e){connectionLost(e);}</b>
<b class="nc">&nbsp;            p.numPlayers = numPlayers;</b>
&nbsp;            try {
<b class="nc">&nbsp;                outStreams.get(i).writeObject(new Player(p));</b>
<b class="nc">&nbsp;            }catch (Exception e){connectionLost(e);}</b>
<b class="nc">&nbsp;            players.add(new PlayerSend(p));</b>
&nbsp;        }
&nbsp;    }
&nbsp;    /**
&nbsp;     * choose a random chairman from all the players who connected to the game
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private void randomizeChairman(){
<b class="nc">&nbsp;        int temp = new Random().nextInt(numPlayers);</b>
<b class="nc">&nbsp;        String n = null;</b>
&nbsp;        try {
<b class="nc">&nbsp;            n = names.get(0);</b>
<b class="nc">&nbsp;        }catch (Exception e){connectionLost(e);}</b>
<b class="nc">&nbsp;        names.set(0, names.get(temp));</b>
<b class="nc">&nbsp;        names.set(temp, n);</b>
&nbsp;
<b class="nc">&nbsp;        ObjectOutputStream outTemp = outStreams.get(0);</b>
<b class="nc">&nbsp;        outStreams.set(0, outStreams.get(temp));</b>
<b class="nc">&nbsp;        outStreams.set(temp, outTemp);</b>
&nbsp;
<b class="nc">&nbsp;        ObjectInputStream inTemp = inStreams.get(0);</b>
<b class="nc">&nbsp;        inStreams.set(0, inStreams.get(temp));</b>
<b class="nc">&nbsp;        inStreams.set(temp, inTemp);</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * helper function which waits for client&#39;s connection to the server socket, when all are connected the game starts
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private void listenForPlayersConnections(){
<b class="nc">&nbsp;        ArrayList&lt;Thread&gt; ths = new ArrayList&lt;&gt;();</b>
&nbsp;        ObjectInputStream clientIn;
&nbsp;        ObjectOutputStream clientOut;
&nbsp;        Thread th;
&nbsp;
<b class="nc">&nbsp;        while(numPlayers &lt; targetPlayers){</b>
&nbsp;            try{
<b class="nc">&nbsp;                playersSocket.add(serverSocket.accept());</b>
<b class="nc">&nbsp;                clientOut = new ObjectOutputStream(playersSocket.get(playersSocket.size() - 1).getOutputStream());</b>
<b class="nc">&nbsp;                clientIn = new ObjectInputStream(playersSocket.get(playersSocket.size() - 1).getInputStream());</b>
<b class="nc">&nbsp;                clientOut.flush();</b>
<b class="nc">&nbsp;                boolean isFake = (boolean) clientIn.readObject();</b>
<b class="nc">&nbsp;                if(isFake) {</b>
<b class="nc">&nbsp;                    playersSocket.remove(playersSocket.size() - 1);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                ObjectInputStream finalClientIn = clientIn;</b>
<b class="nc">&nbsp;                ObjectOutputStream finalClientOut = clientOut;</b>
<b class="nc">&nbsp;                th = new Thread(() -&gt;{</b>
<b class="nc">&nbsp;                    try{getUserName(finalClientIn, finalClientOut);}</b>
<b class="nc">&nbsp;                    catch(Exception e){connectionLost(e);}</b>
&nbsp;                });
<b class="nc">&nbsp;                th.start();</b>
<b class="nc">&nbsp;                ths.add(th);</b>
<b class="nc">&nbsp;                numPlayers++;</b>
&nbsp;            }
<b class="nc">&nbsp;            catch(Exception e){</b>
&nbsp;                try {
<b class="nc">&nbsp;                    playersSocket.get(playersSocket.size() - 1).close();</b>
<b class="nc">&nbsp;                } catch (IOException ex) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(ex);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                playersSocket.remove(playersSocket.size() - 1);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        timeExp = false;</b>
<b class="nc">&nbsp;        for(Thread t: ths){</b>
<b class="nc">&nbsp;            try{t.join();}</b>
<b class="nc">&nbsp;            catch(Exception e){connectionLost(e);}</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if(numPlayers &lt; targetPlayers){</b>
<b class="nc">&nbsp;            System.out.println(&quot;\nPlayer number not sufficient\n&quot;);</b>
<b class="nc">&nbsp;            System.exit(0);</b>
&nbsp;        }
<b class="nc">&nbsp;        System.out.println(&quot;\nThe game started\n&quot;);</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * method that listen for an old client to restart his previous game, in tha same old state
&nbsp;     * @param s the socket of the player
&nbsp;     * @param out the output stream of the player
&nbsp;     * @param in the input stream of the player
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    synchronized private void tryToReconnectClient(Socket s, ObjectOutputStream out, ObjectInputStream in){
&nbsp;        try {
<b class="nc">&nbsp;            String name = (String) in.readObject();</b>
<b class="nc">&nbsp;            if(disconnectedPlayers.contains(name)) {</b>
<b class="nc">&nbsp;                rmiClients.remove(name);</b>
<b class="nc">&nbsp;                out.writeObject(NameStatus.FOUND);</b>
<b class="nc">&nbsp;                PlayerSend p = new PlayerSend(players.get(names.indexOf(name)));</b>
<b class="nc">&nbsp;                p.activeName = names.get(activePlayer);</b>
<b class="nc">&nbsp;                out.writeObject(new Player(p));</b>
<b class="nc">&nbsp;                inStreams.set(names.indexOf(name), in);</b>
<b class="nc">&nbsp;                outStreams.set(names.indexOf(name), out);</b>
<b class="nc">&nbsp;                playersSocket.set(names.indexOf(name), s);</b>
<b class="nc">&nbsp;                boolean temp = (boolean) in.readObject(); //variable used to check if the rmi is ready</b>
<b class="nc">&nbsp;                synchronized (disconnectionLock) {</b>
<b class="nc">&nbsp;                    disconnectedPlayers.remove(name);</b>
<b class="nc">&nbsp;                    if (!rmiClients.containsKey(name)) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            s.setSoTimeout(Player.pingTimeout);</b>
<b class="nc">&nbsp;                        } catch (SocketException e) {</b>
<b class="nc">&nbsp;                            connectionLost(e);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        if (getActivePlayersNumber() &gt;= 3) // if there are only 2 players, the turn will change, so there is no need to listen to the chat</b>
<b class="nc">&nbsp;                            new ChatBroadcast(this, names.indexOf(name)).start();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (getActivePlayersNumber() == 2) {</b>
<b class="nc">&nbsp;                        disconnectedPlayers.remove(name);</b>
<b class="nc">&nbsp;                        if (advance) {</b>
<b class="nc">&nbsp;                            sendToClient(activePlayer, new Message(MessageType.SHOW_EVENT, null, &quot;Player &quot; + name + &quot; reconnected, the game is resuming...&quot;));</b>
<b class="nc">&nbsp;                            Game.waitForSeconds(Game.fastTimer * 1.5);</b>
<b class="nc">&nbsp;                            advance = false;</b>
<b class="nc">&nbsp;                            new Thread(this::advanceTurn).start();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            sendToClient(activePlayer, new Message(MessageType.SHOW_EVENT, null, &quot;Player &quot; + name + &quot; reconnected to the game&quot;));</b>
<b class="nc">&nbsp;                            new ChatBroadcast(this, names.indexOf(name)).start(); // the chat thread will be stopped naturally after the next UPDATE_GAME</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="nc">&nbsp;                        disconnectedPlayers.remove(name);</b>
<b class="nc">&nbsp;                        for (int i = 0; i &lt; numPlayers; i++) {</b>
<b class="nc">&nbsp;                            if (names.get(i).equals(name))</b>
<b class="nc">&nbsp;                                continue;</b>
<b class="nc">&nbsp;                            sendToClient(i, new Message(MessageType.SHOW_EVENT, null, &quot;Player &quot; + name + &quot; reconnected to the game&quot;));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;                else
<b class="nc">&nbsp;                    out.writeObject(NameStatus.NOT_FOUND);</b>
<b class="nc">&nbsp;        }catch (Exception e){</b>
&nbsp;            try {
<b class="nc">&nbsp;                s.close();</b>
<b class="nc">&nbsp;                out.close();</b>
<b class="nc">&nbsp;                in.close();</b>
<b class="nc">&nbsp;            } catch (IOException ignored) {}</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * method that wait permanently for a new client to connect to the existing game
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private void listenForReconnection(){
<b class="nc">&nbsp;        Socket s = null;</b>
&nbsp;        while(true){
&nbsp;            try {
<b class="nc">&nbsp;                s = serverSocket.accept();</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                continue;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            Socket finalS = s;</b>
<b class="nc">&nbsp;            new Thread(() -&gt; {</b>
<b class="nc">&nbsp;                ObjectOutputStream out = null;</b>
<b class="nc">&nbsp;                ObjectInputStream in = null;</b>
&nbsp;                try {
<b class="nc">&nbsp;                    out = new ObjectOutputStream(finalS.getOutputStream());</b>
<b class="nc">&nbsp;                    out.flush();</b>
<b class="nc">&nbsp;                    in = new ObjectInputStream(finalS.getInputStream());</b>
<b class="nc">&nbsp;                } catch (IOException ignored) {}</b>
<b class="nc">&nbsp;                tryToReconnectClient(finalS, out, in);</b>
<b class="nc">&nbsp;            }).start();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Check if the name that the client choose is already TAKEN
&nbsp;     * @param in the input stream of the socket
&nbsp;     * @param out the output stream of the socket
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    synchronized private void getUserName(ObjectInputStream in, ObjectOutputStream out){
&nbsp;        try {
<b class="nc">&nbsp;            outStreams.add(out);</b>
<b class="nc">&nbsp;            inStreams.add(in);</b>
&nbsp;            while (true) {
<b class="nc">&nbsp;                String name = (String) inStreams.get(inStreams.size() - 1).readObject();</b>
<b class="nc">&nbsp;                if (isNameTaken(name)) {</b>
<b class="nc">&nbsp;                    outStreams.get(outStreams.size() - 1).writeObject(NameStatus.TAKEN);</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="nc">&nbsp;                if(gameTemp != null &amp;&amp; gameTemp.names.contains(name))</b>
<b class="nc">&nbsp;                    outStreams.get(outStreams.size() - 1).writeObject(NameStatus.OLD);</b>
&nbsp;                else
<b class="nc">&nbsp;                    outStreams.get(outStreams.size() - 1).writeObject(NameStatus.NOT_TAKEN);</b>
<b class="nc">&nbsp;                names.add(name);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }catch(Exception e){</b>
&nbsp;            try {
<b class="nc">&nbsp;                playersSocket.get(playersSocket.size() - 1).close();</b>
<b class="nc">&nbsp;                outStreams.get(outStreams.size() - 1).close();</b>
<b class="nc">&nbsp;                inStreams.get(inStreams.size() - 1).close();</b>
<b class="nc">&nbsp;            } catch (IOException ignored) {}</b>
<b class="nc">&nbsp;            outStreams.remove(outStreams.size() - 1);</b>
<b class="nc">&nbsp;            inStreams.remove(inStreams.size() - 1);</b>
<b class="nc">&nbsp;            playersSocket.remove(playersSocket.size() - 1);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Make a random choose of the objective (Common and Private)
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private void shuffleObjBucket(){
<b class="nc">&nbsp;        Random rand = new Random();</b>
&nbsp;        CommonObjective temp_1;
&nbsp;        PrivateObjective temp_2;
&nbsp;        int j;
<b class="nc">&nbsp;        for(int i = 0; i &lt; bucketOfCO.size(); i++){</b>
<b class="nc">&nbsp;            j = rand.nextInt(bucketOfCO.size());</b>
<b class="nc">&nbsp;            temp_1 = bucketOfCO.get(i);</b>
<b class="nc">&nbsp;            bucketOfCO.set(i, bucketOfCO.get(j));</b>
<b class="nc">&nbsp;            bucketOfCO.set(j, temp_1);</b>
&nbsp;        }
<b class="nc">&nbsp;        for(int i = 0; i &lt; bucketOfPO.size(); i++){</b>
<b class="nc">&nbsp;            j = rand.nextInt(bucketOfPO.size());</b>
<b class="nc">&nbsp;            temp_2 = bucketOfPO.get(i);</b>
<b class="nc">&nbsp;            bucketOfPO.set(i, bucketOfPO.get(j));</b>
<b class="nc">&nbsp;            bucketOfPO.set(j, temp_2);</b>
&nbsp;        }
&nbsp;    }
&nbsp;    /**
&nbsp;     * Wait the move of the client that are playing and set the chat,
&nbsp;     * when the client made the move and send it to server update Board and Library
&nbsp;     * @author Ettori Faccincani
&nbsp;     */
&nbsp;    private void waitMoveFromClient(){
<b class="nc">&nbsp;            startChatServerThread();</b>
&nbsp;            while (true) {
<b class="nc">&nbsp;                Message msg = null;</b>
&nbsp;                try {
<b class="nc">&nbsp;                    msg = (Message) inStreams.get(activePlayer).readObject();</b>
<b class="nc">&nbsp;                } catch (IOException | ClassNotFoundException e) {</b>
<b class="nc">&nbsp;                    playerDisconnected(activePlayer, e);</b>
&nbsp;                    return;
<b class="nc">&nbsp;                }</b>
&nbsp;                try {
<b class="nc">&nbsp;                    if (msg == null)</b>
<b class="nc">&nbsp;                        continue;</b>
<b class="nc">&nbsp;                    if (msg.getType() == MessageType.PING)</b>
<b class="nc">&nbsp;                        continue;</b>
<b class="nc">&nbsp;                    if (msg.getType() == MessageType.CHAT) {</b>
<b class="nc">&nbsp;                        sendChatToClients(names.get(activePlayer), msg.getAuthor(), (String) msg.getContent());</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if(msg.getType() == MessageType.STOP){</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    for (int i = 0; i &lt; numPlayers; i++) {</b>
<b class="nc">&nbsp;                        if (i != activePlayer)</b>
<b class="nc">&nbsp;                            sendToClient(i, msg);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (msg.getType() == MessageType.LIB_FULL &amp;&amp; !endGameSituation) {</b>
<b class="nc">&nbsp;                        endGameSituation = true;</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (msg.getType() == MessageType.UPDATE_UNPLAYABLE) {</b>
<b class="nc">&nbsp;                        Board b = (Board) msg.getContent();</b>
<b class="nc">&nbsp;                        for (int i = 0; i &lt; numPlayers; i++)</b>
<b class="nc">&nbsp;                            players.get(i).board = new Board(b);</b>
<b class="nc">&nbsp;                        FILEHelper.writeServer(this);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (msg.getType() == MessageType.UPDATE_GAME) {</b>
<b class="nc">&nbsp;                        PlayerSend p = (PlayerSend) msg.getContent();</b>
<b class="nc">&nbsp;                        for (int i = 0; i &lt; numPlayers; i++) {</b>
<b class="nc">&nbsp;                            if (i == activePlayer)</b>
<b class="nc">&nbsp;                                continue;</b>
<b class="nc">&nbsp;                            players.get(i).board = p.board;</b>
<b class="nc">&nbsp;                            players.get(i).pointsMap.put(names.get(activePlayer), p.pointsUntilNow);</b>
<b class="nc">&nbsp;                            for (int j = 0; j &lt; numPlayers - 1; j++) {</b>
<b class="nc">&nbsp;                                if (players.get(i).librariesOfOtherPlayers.get(j).name.equals(names.get(activePlayer)))</b>
<b class="nc">&nbsp;                                    players.get(i).librariesOfOtherPlayers.set(j, p.library);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        players.set(activePlayer, p);</b>
<b class="nc">&nbsp;                        players.get(activePlayer).activeName = names.get(activePlayer);</b>
<b class="nc">&nbsp;                        FILEHelper.writeServer(this);</b>
<b class="nc">&nbsp;                        if (!rmiClients.containsKey(names.get(activePlayer)))</b>
<b class="nc">&nbsp;                            sendToClient(activePlayer, new Message(MessageType.STOP, null, null));</b>
<b class="nc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (Exception e) {</b>
<b class="nc">&nbsp;                    connectionLost(e);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        Game.waitForSeconds(Game.passTimer);</b>
<b class="nc">&nbsp;        advanceTurn();</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Set the status of the players for the next turn and assign activePlayer to who will play this turn
&nbsp;     * @author Ettori Faccincani
&nbsp;     */
&nbsp;    public void advanceTurn(){
<b class="nc">&nbsp;        synchronized (disconnectionLock) {</b>
<b class="nc">&nbsp;            if(getActivePlayersNumber() == 0)</b>
<b class="nc">&nbsp;                connectionLost(new RuntimeException(&quot;All players disconnected&quot;));</b>
<b class="nc">&nbsp;            if (getActivePlayersNumber() == 1 &amp;&amp; disconnectedPlayers.size() &gt; 0) {</b>
<b class="nc">&nbsp;                Game.waitForSeconds(Game.passTimer);</b>
<b class="nc">&nbsp;                sendToClient(getLastPlayer(), new Message(MessageType.SHOW_EVENT, null, &quot;The game is temporarily paused because you are the only connected player&quot;));</b>
<b class="nc">&nbsp;                advance = true;</b>
<b class="nc">&nbsp;                activePlayer = getLastPlayer();</b>
<b class="nc">&nbsp;                new ChatBroadcast(this, activePlayer).start();</b>
<b class="nc">&nbsp;                playerNoChat = names.get(activePlayer);</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;        do{
<b class="nc">&nbsp;            activePlayer = (activePlayer + 1) % numPlayers;</b>
&nbsp;        }
<b class="nc">&nbsp;        while(disconnectedPlayers.contains(names.get(activePlayer)));</b>
<b class="nc">&nbsp;        if(activePlayer == 0 &amp;&amp; endGameSituation) {</b>
<b class="nc">&nbsp;            System.out.println(&quot;\nThe game is ending...&quot;);</b>
<b class="nc">&nbsp;            Game.waitForSeconds(Game.fastTimer);</b>
<b class="nc">&nbsp;            sendFinalScoresToAll();</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        notifyNewTurn();</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Send the message to the client that a new turn start (two cases, if is the turn of the client or is the turn of another client)
&nbsp;     * @author Ettori Faccincani
&nbsp;     */
&nbsp;    private void notifyNewTurn(){
<b class="nc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){</b>
&nbsp;            try {
<b class="nc">&nbsp;                if (i != activePlayer)</b>
<b class="nc">&nbsp;                    sendToClient(i, new Message(MessageType.CHANGE_TURN, &quot;server&quot;, names.get(activePlayer)));</b>
<b class="nc">&nbsp;            }catch (Exception e){connectionLost(e);}</b>
&nbsp;        }
<b class="nc">&nbsp;        new Thread(() -&gt; sendToClient(activePlayer, new Message(MessageType.YOUR_TURN, &quot;server&quot;, &quot;&quot;))).start();</b>
<b class="nc">&nbsp;        if(!rmiClients.containsKey(names.get(activePlayer)))</b>
<b class="nc">&nbsp;            new Thread(this::waitMoveFromClient).start();</b>
&nbsp;        else
<b class="nc">&nbsp;            startChatServerThread();</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * start all the threads that listen for chat messages from the clients (and sends the messages back to the players)
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private void startChatServerThread(){
<b class="nc">&nbsp;        chatThreads = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){</b>
<b class="nc">&nbsp;            if(i == activePlayer || rmiClients.containsKey(names.get(i)) || disconnectedPlayers.contains(names.get(i)) || names.get(i).equals(playerNoChat))</b>
<b class="nc">&nbsp;                continue;</b>
<b class="nc">&nbsp;            chatThreads.add(new ChatBroadcast(this, i));</b>
<b class="nc">&nbsp;            chatThreads.get(chatThreads.size() - 1).start();</b>
&nbsp;        }
<b class="nc">&nbsp;        playerNoChat = &quot;&quot;;</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Send message in the chat to other client
&nbsp;     * @param from who send the message
&nbsp;     * @param to who receive the message
&nbsp;     * @param msg text inside the message
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    public void sendChatToClients(String from, String to, String msg){
&nbsp;        try {
<b class="nc">&nbsp;            if (to.equals(&quot;all&quot;)) {</b>
<b class="nc">&nbsp;                for (int i = 0; i &lt; numPlayers; i++) {</b>
<b class="nc">&nbsp;                    if (!names.get(i).equals(from))</b>
<b class="nc">&nbsp;                        sendToClient(i, new Message(MessageType.CHAT, &quot;&quot;, msg));</b>
<b class="nc">&nbsp;                    players.get(i).fullChat += msg;</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            else if(getNameIndex(to) != -1){</b>
<b class="nc">&nbsp;                sendToClient(getNameIndex(to) ,new Message(MessageType.CHAT, &quot;&quot;, msg));</b>
<b class="nc">&nbsp;                players.get(getNameIndex(to)).fullChat += msg;</b>
<b class="nc">&nbsp;                players.get(getNameIndex(from)).fullChat += msg;</b>
&nbsp;            }
<b class="nc">&nbsp;        }catch (Exception e){connectionLost(e);}</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * find and return the name of the chairman of this game
&nbsp;     * @return the name of the chairman (String)
&nbsp;     */
<b class="nc">&nbsp;    private String getChairmanName(){return names.get(0);}</b>
&nbsp;    /**
&nbsp;     * find and return the chairman Player
&nbsp;     * @return the chairman Object (Player)
&nbsp;     */
<b class="nc">&nbsp;    private PlayerSend getChairman(){return players.get(0);}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * check if the name is already taken by other players
&nbsp;     * @param name the name to check
&nbsp;     * @return true iff the name is already taken
&nbsp;     */
<b class="nc">&nbsp;    private boolean isNameTaken(String name){return names.contains(name);}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * get the index of a certain player, by the name
&nbsp;     * @param name the name of the player
&nbsp;     * @return the index of the player having that name, -1 if not found
&nbsp;     */
&nbsp;    private int getNameIndex(String name){
<b class="nc">&nbsp;        for(int i = 0; i &lt; names.size(); i++){</b>
<b class="nc">&nbsp;            if(names.get(i).equals(name))</b>
<b class="nc">&nbsp;                return i;</b>
&nbsp;        }
<b class="nc">&nbsp;        return -1;</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * choose the private objective, one for every player
&nbsp;     * @return the chosen private objective
&nbsp;     */
&nbsp;    private PrivateObjective getPrivateObjective(){
<b class="nc">&nbsp;        PrivateObjective res = bucketOfPO.get(0);</b>
<b class="nc">&nbsp;        bucketOfPO.remove(0);</b>
<b class="nc">&nbsp;        return res;</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Count the points at the end of the game (not private or common objective)
&nbsp;     * and sum to the points made until now
&nbsp;     * @return the order of the player each one with his score
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private String getFinalScore(){
<b class="nc">&nbsp;        ArrayList&lt;Integer&gt; scores = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        StringBuilder res = new StringBuilder();</b>
&nbsp;        PlayerSend p;
<b class="nc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){</b>
<b class="nc">&nbsp;            p = players.get(i);</b>
<b class="nc">&nbsp;            scores.add(p.pointsUntilNow + p.library.countGroupedPoints() + p.objective.countPoints(p.library.gameLibrary));</b>
&nbsp;        }
&nbsp;        String tempName;
&nbsp;        int tempScore;
<b class="nc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++){</b>
<b class="nc">&nbsp;            for(int j = i; j &lt; numPlayers; j++){</b>
<b class="nc">&nbsp;                if(scores.get(j) &lt; scores.get(i)){</b>
<b class="nc">&nbsp;                    tempName = names.get(i);</b>
<b class="nc">&nbsp;                    tempScore = scores.get(i);</b>
<b class="nc">&nbsp;                    names.set(i, names.get(j));</b>
<b class="nc">&nbsp;                    scores.set(i, scores.get(j));</b>
<b class="nc">&nbsp;                    names.set(j, tempName);</b>
<b class="nc">&nbsp;                    scores.set(j, tempScore);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        Collections.reverse(names);</b>
<b class="nc">&nbsp;        Collections.reverse(scores);</b>
<b class="nc">&nbsp;        for(int i = 0; i &lt; numPlayers; i++)</b>
<b class="nc">&nbsp;            res.append(&quot;Place number &quot;).append(i + 1).append(&quot;: &quot;).append(names.get(i)).append(&quot; with &quot;).append(scores.get(i)).append(&quot; points\n&quot;);</b>
<b class="nc">&nbsp;        return res.toString();</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * Send the final score to all the clients
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private void sendFinalScoresToAll(){
<b class="nc">&nbsp;        String finalScores = getFinalScore();</b>
<b class="nc">&nbsp;        FILEHelper.writeSucc(); // the server finished with success, so nothing has to be written in the cache</b>
<b class="nc">&nbsp;        Thread finalTh = new Thread(() -&gt;{</b>
<b class="nc">&nbsp;            for(int i = 0; i &lt; numPlayers; i++)</b>
<b class="nc">&nbsp;                sendToClient(i, new Message(MessageType.FINAL_SCORE, &quot;server&quot;, finalScores));</b>
&nbsp;        });
<b class="nc">&nbsp;        finalTh.start();</b>
&nbsp;        try {
<b class="nc">&nbsp;            finalTh.join();</b>
<b class="nc">&nbsp;        } catch (InterruptedException e) {</b>
<b class="nc">&nbsp;            connectionLost(e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        System.out.println(&quot;The game is finished successfully&quot;);</b>
<b class="nc">&nbsp;        Game.waitForSeconds(Game.waitTimer * 5);</b>
<b class="nc">&nbsp;        System.exit(0);</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * getter for the input streams from the server to all the clients
&nbsp;     * @return the ArrayList containing all the input streams
&nbsp;     */
<b class="nc">&nbsp;    public ArrayList&lt;ObjectInputStream&gt; getInStreams(){return inStreams;}</b>
&nbsp;    /**
&nbsp;     * getter for the list of names of the players active in this game
&nbsp;     * @return the ArrayList containing all the names of the connected players
&nbsp;     */
<b class="nc">&nbsp;    public ArrayList&lt;String&gt; getNames(){return names;}</b>
&nbsp;    /**
&nbsp;     * shortcut for the Thread.sleep(int) function, it accepts SECONDS, NOT MILLISECONDS
&nbsp;     * @param n the (decimal) number of seconds to wait
&nbsp;     */
&nbsp;    public static void waitForSeconds(double n){
&nbsp;        try {
<b class="nc">&nbsp;            Thread.sleep((long) (n * 1000));</b>
<b class="nc">&nbsp;        } catch (InterruptedException ignored) {}</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * function that handle the eventual disconnection
&nbsp;     * @param e the exception to throw
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    public void connectionLost(Exception e){
<b class="nc">&nbsp;        if(closed)</b>
&nbsp;            return;
&nbsp;        //e.printStackTrace();
<b class="nc">&nbsp;        if(Game.showErrors)</b>
<b class="nc">&nbsp;            throw new RuntimeException(e);</b>
&nbsp;        else{
<b class="nc">&nbsp;            closed = true;</b>
<b class="nc">&nbsp;            System.out.println(&quot;\nConnection lost, the server is closing...\n&quot;);</b>
<b class="nc">&nbsp;            new Thread(() -&gt;{</b>
&nbsp;                try {
<b class="nc">&nbsp;                    for(Socket s: playersSocket)</b>
<b class="nc">&nbsp;                        s.close();</b>
<b class="nc">&nbsp;                    for(ObjectOutputStream out: outStreams)</b>
<b class="nc">&nbsp;                        out.close();</b>
<b class="nc">&nbsp;                    serverSocket.close();</b>
<b class="nc">&nbsp;                } catch (Exception ignored) {}</b>
<b class="nc">&nbsp;            }).start();</b>
<b class="nc">&nbsp;            Game.waitForSeconds(Game.fastTimer * 1.5);</b>
<b class="nc">&nbsp;            System.exit(0);</b>
&nbsp;        }
&nbsp;    }
&nbsp;    /**
&nbsp;     * method which acknowledge that one of the client disconnected and set the game to continue without the lost client
&nbsp;     * @param i the index of the lost client
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;     public void playerDisconnected(int i, Exception exc) {
<b class="nc">&nbsp;         synchronized (disconnectionLock) {</b>
<b class="nc">&nbsp;             if (Game.showErrors)</b>
<b class="nc">&nbsp;                 connectionLost(exc);</b>
<b class="nc">&nbsp;             if (disconnectedPlayers.contains(names.get(i)))</b>
<b class="nc">&nbsp;                 return;</b>
&nbsp;             //System.out.println(&quot;disco &quot; + names.get(i));
&nbsp;             try {
<b class="nc">&nbsp;                 playersSocket.get(i).setSoTimeout(0);</b>
<b class="nc">&nbsp;                 outStreams.get(i).flush();</b>
<b class="nc">&nbsp;             } catch (IOException ignored) {}</b>
<b class="nc">&nbsp;             disconnectedPlayers.add(names.get(i));</b>
<b class="nc">&nbsp;             rmiClients.remove(names.get(i));</b>
<b class="nc">&nbsp;         }</b>
<b class="nc">&nbsp;         if (getActivePlayersNumber() == 1)</b>
<b class="nc">&nbsp;             new Thread(this::disconnectedTimer).start();</b>
<b class="nc">&nbsp;         if(getActivePlayersNumber() == 0){</b>
<b class="nc">&nbsp;             System.out.println(&quot;The server is closing because there are no connected players...&quot;);</b>
<b class="nc">&nbsp;             System.exit(0);</b>
&nbsp;         }
<b class="nc">&nbsp;         if (i == activePlayer){</b>
<b class="nc">&nbsp;             for (int j = 0; j &lt; numPlayers; j++) {</b>
<b class="nc">&nbsp;                 int finalJ = j;</b>
<b class="nc">&nbsp;                 new Thread(() -&gt; sendToClient(finalJ, new Message(MessageType.DISCONNECTED, names.get(i), null))).start();</b>
&nbsp;             }
<b class="nc">&nbsp;             if(getActivePlayersNumber() &gt; 1){</b>
<b class="nc">&nbsp;                 Game.waitForSeconds(Game.fastTimer);</b>
<b class="nc">&nbsp;                 advanceTurn();</b>
&nbsp;             }
&nbsp;             else{
<b class="nc">&nbsp;                 activePlayer = getLastPlayer();</b>
<b class="nc">&nbsp;                 Game.waitForSeconds(Game.fastTimer);</b>
<b class="nc">&nbsp;                 notifyNewTurn();</b>
&nbsp;             }
&nbsp;         }
&nbsp;         else{
<b class="nc">&nbsp;             for(int x = 0; x &lt; numPlayers; x++){</b>
<b class="nc">&nbsp;                 if(!disconnectedPlayers.contains(names.get(x))) {</b>
<b class="nc">&nbsp;                     sendToClient(x, new Message(MessageType.LOST_CLIENT, names.get(i), null));</b>
&nbsp;                 }
&nbsp;             }
&nbsp;         }
&nbsp;     }
&nbsp;    /**
&nbsp;     * method that checks if one player has been alone for more than 1 minute, in that case that player is declared winner and the game end
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    private void disconnectedTimer(){
<b class="nc">&nbsp;        int name = getLastPlayer();</b>
<b class="nc">&nbsp;        Game.waitForSeconds(30);</b>
<b class="nc">&nbsp;        if(getActivePlayersNumber() != 1)</b>
&nbsp;            return;
<b class="nc">&nbsp;        Game.waitForSeconds(30);</b>
<b class="nc">&nbsp;        if(getActivePlayersNumber() != 1)</b>
&nbsp;            return;
<b class="nc">&nbsp;        Game.waitForSeconds(30);</b>
<b class="nc">&nbsp;        if(getActivePlayersNumber() == 1 &amp;&amp; getLastPlayer() == name){</b>
<b class="nc">&nbsp;            FILEHelper.writeSucc();</b>
<b class="nc">&nbsp;            sendToClient(getLastPlayer(), new Message(MessageType.SHOW_EVENT, &quot;win&quot;, &quot;You have won because all the other players have disconnected&quot;));</b>
<b class="nc">&nbsp;            Game.waitForSeconds(Game.waitTimer * 3);</b>
<b class="nc">&nbsp;            System.exit(0);</b>
&nbsp;        }
&nbsp;    }
&nbsp;    /**
&nbsp;     * method that find the number of players which are currently connected to the game
&nbsp;     * @author Ettori
&nbsp;     * @return the number of connected players
&nbsp;     */
<b class="nc">&nbsp;    private int getActivePlayersNumber(){return numPlayers - disconnectedPlayers.size();}</b>
&nbsp;    /**
&nbsp;     * general method to respond to a client, it chooses the right network connection of the player
&nbsp;     * @author Ettori
&nbsp;     * @param i the index of the player to contact
&nbsp;     * @param msg the message that must be sent
&nbsp;     */
&nbsp;    public void sendToClient(int i, Message msg){
<b class="nc">&nbsp;        if(i &lt; 0 || i &gt;= names.size())</b>
<b class="nc">&nbsp;            throw new RuntimeException(&quot;Sending to a NON existing player&quot;);</b>
<b class="nc">&nbsp;        if (disconnectedPlayers.contains(names.get(i)))</b>
&nbsp;            return;
&nbsp;        //System.out.println(&quot;Sending &quot; + msg.getType() + &quot; to &quot; + names.get(i));
<b class="nc">&nbsp;        if (!rmiClients.containsKey(names.get(i)) || msg.getType() == MessageType.FINAL_SCORE) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                outStreams.get(i).writeObject(msg);</b>
<b class="nc">&nbsp;            } catch (IOException e) {</b>
<b class="nc">&nbsp;                playerDisconnected(i, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        } else {
&nbsp;            try {
<b class="nc">&nbsp;                rmiClients.get(names.get(i)).receivedEventRMI(msg);</b>
<b class="nc">&nbsp;            } catch (RemoteException e) {</b>
<b class="nc">&nbsp;                playerDisconnected(i, e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;    /******************************************** RMI ***************************************************************/
&nbsp;    /**
&nbsp;     * method called from remote used to add a client to the store of all the RMI clients
&nbsp;     * @author Ettori
&nbsp;     * @param name the nickname of the player
&nbsp;     * @param p the player object, passed as the remote interface
&nbsp;     */
&nbsp;    public void addClient(String name, PlayerI p){
<b class="nc">&nbsp;        rmiClients.put(name, p);</b>
&nbsp;    }
&nbsp;    /**
&nbsp;     * method called from remote which is equivalent to the waitMoveFromClient() method for the socket
&nbsp;     * @author Ettori
&nbsp;     * @param msg the message that the client want to send to the remote server
&nbsp;     */
&nbsp;    public void redirectToClientRMI(Message msg){
<b class="nc">&nbsp;        switch (msg.getType()){</b>
&nbsp;            case CHAT -&gt; {
<b class="nc">&nbsp;                String from = (String)msg.getContent();</b>
<b class="nc">&nbsp;                from = from.substring(0, from.indexOf(&quot; &quot;));</b>
<b class="nc">&nbsp;                sendChatToClients(from, msg.getAuthor(), (String)msg.getContent());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            case UPDATE_GAME -&gt; {
<b class="nc">&nbsp;                    for (int i = 0; i &lt; numPlayers; i++) {</b>
<b class="nc">&nbsp;                        if (i != activePlayer)</b>
<b class="nc">&nbsp;                            sendToClient(i, msg);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    PlayerSend p = (PlayerSend) msg.getContent();</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; numPlayers; i++) {</b>
<b class="nc">&nbsp;                        if (i == activePlayer)</b>
<b class="nc">&nbsp;                            continue;</b>
<b class="nc">&nbsp;                        players.get(i).board = p.board;</b>
<b class="nc">&nbsp;                        players.get(i).pointsMap.put(names.get(activePlayer), p.pointsUntilNow);</b>
<b class="nc">&nbsp;                        for (int j = 0; j &lt; numPlayers - 1; j++) {</b>
<b class="nc">&nbsp;                            if (players.get(i).librariesOfOtherPlayers.get(j).name.equals(names.get(activePlayer)))</b>
<b class="nc">&nbsp;                                players.get(i).librariesOfOtherPlayers.set(j, p.library);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    players.set(activePlayer, p);</b>
<b class="nc">&nbsp;                    players.get(activePlayer).activeName = names.get(activePlayer);</b>
<b class="nc">&nbsp;                    FILEHelper.writeServer(this);</b>
<b class="nc">&nbsp;                    if (!rmiClients.containsKey(names.get(activePlayer)))</b>
<b class="nc">&nbsp;                        sendToClient(activePlayer, new Message(MessageType.STOP, null, null));</b>
<b class="nc">&nbsp;                Game.waitForSeconds(Game.passTimer);</b>
<b class="nc">&nbsp;                advanceTurn();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            case PING, STOP -&gt;{}</b>
&nbsp;            default -&gt; {
<b class="nc">&nbsp;                if(msg.getType() == MessageType.LIB_FULL &amp;&amp; !endGameSituation)</b>
<b class="nc">&nbsp;                    endGameSituation = true;</b>
<b class="nc">&nbsp;                if(msg.getType() == MessageType.UPDATE_UNPLAYABLE){</b>
<b class="nc">&nbsp;                    Board b = (Board) msg.getContent();</b>
<b class="nc">&nbsp;                    for (int i = 0; i &lt; numPlayers; i++)</b>
<b class="nc">&nbsp;                        players.get(i).board = new Board(b);</b>
<b class="nc">&nbsp;                    FILEHelper.writeServer(this);</b>
&nbsp;                }
<b class="nc">&nbsp;                for (int i = 0; i &lt; numPlayers; i++) {</b>
<b class="nc">&nbsp;                    if (i != activePlayer)</b>
<b class="nc">&nbsp;                        sendToClient(i,msg);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;    /**
&nbsp;     * method that allow the server to be pinged from an RMI client
&nbsp;     * @author Ettori
&nbsp;     */
<b class="nc">&nbsp;    public void ping(){}</b>
&nbsp;
&nbsp;    /**
&nbsp;     * method that periodically pings all the current client connected with RMI
&nbsp;     * @author Ettori
&nbsp;     */
&nbsp;    public void pingRMI(){
<b class="nc">&nbsp;        AtomicBoolean flag = new AtomicBoolean(false);</b>
&nbsp;        while(true){
<b class="nc">&nbsp;            Game.waitForSeconds(Game.waitTimer * 2);</b>
<b class="nc">&nbsp;            for(String n: names){</b>
<b class="nc">&nbsp;                if(!rmiClients.containsKey(n) || disconnectedPlayers.contains(n) || (endGameSituation &amp;&amp; activePlayer == 0))</b>
<b class="nc">&nbsp;                    continue;</b>
<b class="nc">&nbsp;                flag.set(false);</b>
<b class="nc">&nbsp;                new Thread(() -&gt;{</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        rmiClients.get(n).pingClient();</b>
<b class="nc">&nbsp;                        flag.set(true);</b>
<b class="nc">&nbsp;                    } catch (RemoteException e) {</b>
<b class="nc">&nbsp;                        playerDisconnected(names.indexOf(n), e);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }).start();</b>
<b class="nc">&nbsp;                Game.waitForSeconds(Game.fastTimer);</b>
<b class="nc">&nbsp;                if(!flag.get())</b>
<b class="nc">&nbsp;                    playerDisconnected(names.indexOf(n), new RuntimeException(&quot;Player Disconnected&quot;));</b>
&nbsp;                //System.out.println(&quot;Pingo &quot; + n);
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-24 15:18</div>
</div>
</body>
</html>
